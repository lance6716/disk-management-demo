# 提升磁盘利用率

只针对特定的使用模式考虑磁盘利用率的提升：
从 1 到 1024 的均匀分布独立采样作为 alloc 单元数。
当磁盘空间不足时，记录此时的磁盘利用率，依次遍历已分配的空间并以 10% 概率释放，然后继续分配流程。
总分配量达到某个值后停止。
其对应的单元测试是 `TestUtilizationAfter10TiB`，见 `impl_manager_test.go`。

初始逻辑的测试结果是

```
=== RUN   TestUtilizationAfter10TiB
    impl_manager_test.go:272: seed: 1709964041596581000
    impl_manager_test.go:343: Utilization: [99.999913% 98.354699% 97.317900% 96.570294% 96.032525% 95.724999% 95.492416% 95.264301% 95.163767% 95.029206% 94.966891% 94.915130% 94.874726% 94.838214% 94.785470% 94.795890% 94.837300% 94.821540% 94.814344% 94.850726% 94.845736% 94.859677% 94.824886% 94.836536% 94.832542% 94.793834% 94.825467% 94.859873% 94.833379% 94.835045% 94.825442% 94.876927% 94.878536% 94.873445% 94.871238% 94.819171% 94.803905% 94.823331% 94.796640% 94.841178% 94.827731% 94.812960% 94.850942% 94.847603% 94.893415% 94.911949% 94.895219% 94.885644% 94.830807% 94.826685% 94.829367% 94.794064% 94.790052% 94.817631% 94.813680% 94.809109% 94.832977% 94.843429% 94.829956% 94.849166% 94.820075% 94.812417% 94.852768% 94.825593% 94.854229% 94.872114% 94.859844% 94.814712% 94.754315% 94.739783% 94.794821% 94.815470% 94.805817% 94.848766% 94.816913% 94.766689% 94.761992% 94.797608% 94.836766% 94.837907% 94.829079% 94.804231% 94.748427% 94.770925% 94.764468% 94.812043% 94.845752% 94.848675% 94.824683% 94.791204% 94.779624% 94.732437% 94.790490% 94.757061% 94.799866% 94.827519% 94.846262%]
         Total time: 15.12007097s, Total allocs: 5266907, Total frees: 4771389, Average time/alloc: 1.817µs, Average time/free: 1.162µs
--- PASS: TestUtilizationAfter10TiB (17.05s)
```

我们可以观察到，初始逻辑的磁盘利用率会最终收敛在 94.8% 左右。
这提示我们，在长期运行的场景下，如果随着擦写量增加，磁盘利用率会收敛到一个稳定值。
（是否考虑放弃早期的磁盘利用率，让最终的收敛值更高？）

由于目前实现是连续分配磁盘空间的，在连续的 alloc 调用后只会在空间末尾留下空闲的空间。
首次空间不足时的“磁盘空闲率”上界是 1023/256Mi，即磁盘利用率下界约为是 0.999996189，与测试结果一致。
alloc 调用次数的期望接近 256Mi/512.5 ~= 512Ki。

首次释放空间时，情况变得复杂。首先考虑最理想情况，此时释放的空闲空间仅在末尾连续分布，这样重新进入分配时与初始化时状态无异。
次理想情况是，只有一个空闲空间没有连接到末尾上。
这样重新进入分配时，如果我们能把这个空间恰好分配给 alloc 同样大小的请求，那么利用率就不会劣化。

这种思路可以推广到具有一个较大空闲空间，以及多个较小空闲空间的情况。
在 alloc 请求到来时，如果某个较小空闲空间恰好满足请求，那么把它分配给 alloc，否则分配较大空闲空间。
如果在磁盘满时，所有的较小空闲空间都被分配，那么磁盘利用率就不会劣化。
这种思路还有两个细节问题需要确认：
问题 1：较大空闲空间是怎么产生的
问题 2：较大空闲空间被逐渐分配殆尽的行为是什么

对于这两个问题的回答，有如下两种方案：

方案 1：提前预留一段空间作为“较大空闲空间”。
但是预留的空间如果服务于“未匹配较小空闲空间”的次数太多，其本身就会逐渐变小、从而失去作用。
如果服务于“未匹配较小空闲空间”的次数太少，那么它本身没有带来好处，相当于没有作用。
这种方案难以权衡上面的矛盾，预计效果并不好。

方案 2：随着释放记录目前最大的连续空闲空间作为“较大连续空间”，在选定的“较大连续空间”被分配殆尽时，重新选定目前最大的连续空闲空间作为“较大连续空间”。
考虑到 alloc 调用次数的期望接近 512Ki，我们以 10% 的概率释放空间，不考虑 alloc 大小的随机，连续释放空间对应的 alloc 次数定义为 X。
随机变量 X 符合参数为 0.9 的几何分布，其值域是 [0, +∞)。
模拟该方案产生的 X，见 `util_test.go`。

```
=== RUN   TestGeometricDistribution
    util_test.go:96: seed: 1709968506237985000
    util_test.go:115: X distribution: map[0:424929 1:42454 2:4124 3:457 4:44 5:4 6:1]
--- PASS: TestGeometricDistribution (0.02s)
```

整理上面的思路，方案如下：

1. 额外维护 maxContinuesFree 表示一个“较大的连续空间”
2. 在 alloc 时，如果没有恰好相等的空闲空间，从 maxContinuesFree 中分配
3. 在 maxContinuesFree 用尽时，重新选定目前最大的连续空闲空间作为 maxContinuesFree

为了方便实现，maxContinuesFree 不会属于 oneLengthBucket，即它的长度不会小于 128

## 测试结果

擦写量 10TiB

```
=== RUN   TestUtilizationAfter10TiB
    impl_manager_test.go:288: seed: 1709982138098643000
    impl_manager_test.go:366: Utilization: max 99.999848%, min 99.331115%, avg 99.408510%
         Total time: 5.676323376s, Total allocs: 5255356, Total frees: 4735538, Average time/alloc: 613ns, Average time/free: 517ns
--- PASS: TestUtilizationAfter10TiB (7.68s)
```

擦写量 100TiB 时

```
=== RUN   TestUtilizationAfter100TiB
    impl_manager_test.go:288: seed: 1709982178190500000
    impl_manager_test.go:366: Utilization: max 99.999910%, min 99.283191%, avg 99.408665%
         Total time: 1m4.224638611s, Total allocs: 52422049, Total frees: 51901639, Average time/alloc: 695ns, Average time/free: 535ns
--- PASS: TestUtilizationAfter100TiB (85.50s)
```

## 一个简化版的实现

在上面的实现中，我们维护了一个 maxContinuesFree，在精确匹配失败时从中分配。
这种思路可以简化为，在精确匹配失败时，现场随机选择一个较大的连续空间进行分配。
这可以在 freeSpace 维护的桶中降序选择进行分配来实现。

代码位于 `test-simple-impl` 分支上，粘贴它的测试效果

```
=== RUN   TestUtilizationAfter10TiB
    impl_manager_test.go:275: seed: 1709980645452205000
    impl_manager_test.go:353: Utilization: max 99.999899%, min 98.707556%, avg 99.116611%
         Total time: 4.458005023s, Total allocs: 5245198, Total frees: 4724853, Average time/alloc: 532ns, Average time/free: 352ns
--- PASS: TestUtilizationAfter10TiB (6.35s)
```

```
=== RUN   TestUtilizationAfter100TiB
    impl_manager_test.go:279: seed: 1709980677604953000
    impl_manager_test.go:357: Utilization: max 99.999955%, min 98.765172%, avg 99.138116%
         Total time: 48.448216017s, Total allocs: 52396228, Total frees: 51876353, Average time/alloc: 576ns, Average time/free: 351ns
--- PASS: TestUtilizationAfter100TiB (68.47s)
```

简化后，磁盘利用率略低一些。
